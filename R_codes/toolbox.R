# Functions for the manuscript "Understanding the variability of 
# pairwise coexistence within multispecies systems" by 
# Deng, Taylor and Saavedra.

# load necessary packages
library(tidyverse)
library(mvtnorm)
library(mgcv)
library(magrittr)
library(coneproj) # use function `check_irred(mat)` to check 
library(gtools) # permutation with repeats

# function that computes the normalized feasibility from an interaction matrix
# inputs: alpha = interaction matrix
# output: out = the normalized feasibility
# !!! double check community or species level
Omega <- function(alpha) {
  alpha <- as.matrix(alpha)
  S <- nrow(alpha)
  omega <- function(S, Sigma) {
    m <- matrix(0, S, 1)
    a <- matrix(0, S, 1)
    b <- matrix(Inf, S, 1)
    d <- pmvnorm(lower = rep(0, S), upper = rep(Inf, S), mean = rep(0, S), sigma = Sigma)
    # out <- d[1]^(1 / S) # species level
    out <- d[1] # community level
    return(out)
  }
#   if (length(which(diag(alpha) == 0)) == 0) {
#     Sigma <- chol2inv(alpha, size = NCOL(alpha), LINPACK = FALSE)
#     return(omega(S, Sigma))
#   }
#   else {
    f <- function(m) class(try(solve(t(m) %*% m), silent = T)) == "matrix"
    if (all(f(alpha) == FALSE)) {
      return(0)
    }
    else {
      Sigma <- solve(t(alpha) %*% alpha)
      return(omega(S, Sigma))
    }
#   }
# }
}

# function that normalizes a vector in the L2 norm
# inputs: a = the orignal vector
# output: the normalized vector
normalization <- function(a) {
  a / sqrt(sum(a^2))
}

# function that normalizes the spanning vectors of the feasibility domain in the L2 norm
# inputs: alpha = interaction matrix
# output: Span = the normalized spanning vectors
span_vectors <- function(alpha) {
  Span <- matrix(0, ncol = ncol(alpha), nrow = nrow(alpha))
  for (k in 1:ncol(alpha)) {
    Span[, k] <- -alpha[, k] / sqrt(sum(alpha[, k]^2))
  }
  Span
}

# function that computes all the extreme points that belong to original vertexes
# inputs: A = one interaction matrix, B = another interaction matrix
# output: inside_vertex = all the extreme points that belong to original vertexes
inside_vertex_detection <- function(A, B) {
  SpanA <- span_vectors(A)
  SpanB <- span_vectors(B)
  # to determine whether a vertex of one cone is inside another cone or not.
  inside_detection <- function(Span, vector) {
    lambda <- solve(Span, vector)
    if (sum(lambda >= -1e-10) == length(lambda)) {
      return(1)
    } else {
      return(0)
    }
  }
  inside_vertex <- list()
  l <- 1
  for (i in 1:ncol(B)) {
    auxi <- inside_detection(SpanA, SpanB[, i])
    if (auxi == 1) {
      inside_vertex[[l]] <- SpanB[, i]
      l <- l + 1
    }
  }
  for (i in 1:ncol(A)) {
    auxi <- inside_detection(SpanB, SpanA[, i])
    if (auxi == 1) {
      inside_vertex[[l]] <- SpanA[, i]
      l <- l + 1
    }
  }
  return(inside_vertex)
}

# function that computes all the extreme points generated that are generated by the intersections of the cones
# inputs: S = one interaction matrix, M = another interaction matrix
# output: intersection_vertex = all the extreme points that are generated by the intersections of the cones
intersection_vertex_detection <- function(S, M) {
  num <- ncol(S)
  combination_S <- combn(1:ncol(S), 2)
  combination_M <- combn(1:ncol(S), (num - 1))
  Span_S <- span_vectors(S)
  Span_M <- span_vectors(M)

  border_M <- list()
  extreme_point_M <- list()
  for (i in 1:ncol(M)) {
    coeff_matrix <- matrix(1, ncol = num, nrow = num)
    for (j in 1:(num - 1))
      coeff_matrix[j, ] <- Span_M[, combination_M[j, i]]
    coeff_vector <- c(rep(0, num - 1), 1)
    border_M[[i]] <- solve(coeff_matrix, coeff_vector)
    extreme_point_M[[i]] <- t(coeff_matrix)[1:(num - 1), 1:(num - 1)]
  }

  inside_face_detection <- function(extreme_point, test_vector) {
    lambda <- solve(extreme_point, test_vector)
    if (sum(lambda >= -1e-10) == length(lambda)) {
      return(1)
    } else {
      return(0)
    }
  }

  l <- 1
  intersection_vertex <- list()
  side <- c()
  for (i in 1:ncol(combination_S)) {
    vertex_1 <- Span_S[, combination_S[1, i]]
    vertex_2 <- Span_S[, combination_S[2, i]]
    for (j in 1:length(border_M)) {
      n1 <- sum(vertex_1 * border_M[[j]])
      n2 <- sum(vertex_2 * border_M[[j]])

      auxi <- n1 * n2
      if (auxi < -1e-10) {
        lambda <- n2 / (n2 - n1)
        possible <- lambda * vertex_1 + (1 - lambda) * vertex_2
        if (det(extreme_point_M[[j]]) != 0) {
          auxi2 <- inside_face_detection(extreme_point_M[[j]], possible[1:(num - 1)])
          if (auxi2 == 1) {
            intersection_vertex[[l]] <- possible
            side[l] <- j
            l <- l + 1
          }
        }
      }
    }
  }

  if (length(intersection_vertex) > 0) {
    for (i in 1:length(intersection_vertex)) {
      intersection_vertex[[i]] <- normalization(intersection_vertex[[i]])
    }
  }

  return(intersection_vertex)
}

# function that computes all the extreme points
# inputs: A = one interaction matrix, B = another interaction matrix
# output: out = all the extreme points that generate the intersection region
vertex_detection <- function(A, B) {
  num <- ncol(A)
  inside_vertex <- inside_vertex_detection(A, B)
  intersection_vertex <- intersection_vertex_detection(A, B)

  # combine the two vertex lists
  if (length(inside_vertex) > 0) {
    vertex <- matrix(unlist(inside_vertex), nrow = num, byrow = FALSE)
  } else {
    vertex <- matrix(0, nrow = num, ncol = 2)
  }
  if (length(intersection_vertex) > 0) {
    vertex <- cbind(vertex, matrix(unlist(intersection_vertex), nrow = num, byrow = FALSE))
  }

  # delete the points that are nonzero due to numerical error
  delete_zeroes <- c()
  for (i in 1:ncol(vertex)) {
    if (near(sum(vertex[, i]^2), 0)) {
      delete_zeroes <- c(delete_zeroes, i)
    }
  }
  if (length(delete_zeroes) > 0) vertex <- vertex[, -delete_zeroes]


  # delete the same ones
  if (length(vertex) > num) {
    for (test in 1:ncol(vertex)) {
      vertex[, test] <- normalization(vertex[, test])
    }
    delete_duplicates <- c()
    for (i in 1:(ncol(vertex) - 1)) {
      for (j in (i + 1):ncol(vertex)) {
        if (sum(near(vertex[, i], vertex[, j])) == nrow(vertex)) {
          delete_duplicates <- c(delete_duplicates, j)
        }
      }
    }
    if (length(delete_duplicates) > 0) vertex <- vertex[, -unique(delete_duplicates)]
  }
  return(vertex)
}

# function that computes all the extreme points
# inputs: p = the list of all extreme points
# output: out = all the extreme points that generate the intersection region
partitionize <- function(p) {
  triangulize <- function(p) {
    set.seed(100)
    inside_detection <- function(Span, vector) {
      lambda <- solve(Span, vector)
      if (sum(lambda >= -1e-10) == length(lambda)) {
        return(1)
      } else {
        return(0)
      }
    }
    border <- function(position) {
      coeff_matrix <- t(p[, position])
      coeff_matrix <- rbind(coeff_matrix, 1)
      coeff_vector <- c(rep(0, NR - 1), 1)
      if (abs(det(coeff_matrix)) > 1e-10) {
        border_M <- solve(coeff_matrix, coeff_vector)
      } else {
        border_M <- rep(0, NR)
      }
      return(border_M)
    }
    side_determine <- function(all_del) {
      # choose a candidate
      candidate <- sample(setdiff(c(1:NC), all_del), NR - 1)
      candidate_face <- border(candidate)

      # check which side other points are
      side <- rep(0, ncol(p))
      for (j in 1:length(side)) {
        side[j] <- sum(p[, j] * candidate_face)
      }
      side <- ifelse(abs(side) < 1e-10, 0, side)
      left_side <- which(side < 0)
      right_side <- which(side > 0)
      left_side <- setdiff(left_side, all_del)
      right_side <- setdiff(right_side, all_del)

      abundant_side <- which(side == 0)
      abundant_side <- setdiff(abundant_side, all_del)
      abundant_side <- setdiff(abundant_side, candidate)

      if (length(left_side) == 1) {
        all_del <- c(all_del, left_side)
        all_del <- unique(c(all_del, abundant_side))
        return(list(all_del, c(candidate, left_side)))
      }
      else if (length(right_side) == 1) {
        all_del <- c(all_del, right_side)
        all_del <- unique(c(all_del, abundant_side))
        return(list(all_del, c(candidate, right_side)))
      }
      else {
        return(c())
      }
    }
    isolation_finder <- function(all_del) {
      try <- side_determine(all_del)
      while (length(try) == 0) {
        try <- side_determine(all_del)
      }
      return(try)
    }
    NR <- nrow(p)
    NC <- ncol(p)
    partition <- matrix(0, nrow = 1, ncol = NR)
    all_del <- c()
    while (length(setdiff(c(1:NC), all_del)) >= NR) {
      result <- isolation_finder(all_del)
      all_del <- result[[1]]
      if (length(result) > 1) partition <- rbind(partition, result[[2]])
    }
    # partition
    partition <- partition[-1, ]
    partition <- matrix(partition, ncol = NR)
    # partition <- partition[!duplicated(partition[,]),]
    return(partition)
  }
  # if the number of vertexes is the same as the dimension
  if (nrow(p) == ncol(p)) {
    matrix(1:(nrow(p)), nrow = 1)
  }
  # else it is a triangulization problem
  else {
    return(triangulize(p))
  }
}

# function that computes the full volume
# inputs: partition = triangulation of the intersection region, vertex = all the extreme points
# output: the normalize feasibility of the intersection region
total_volume <- function(partition, vertex) {
  vol <- c()
  num <- ncol(partition)
  if (length(partition) == num) {
    auxi <- vertex[, partition]
    if (near(det(auxi), 0)) {
      vol <- 0
    } else {
      vol <- Omega(auxi)
    }
  } else {
    for (i in 1:nrow(partition)) {
      auxi <- vertex[, partition[i, ]]
      if (near(det(auxi), 0)) {
        vol[i] <- 0
      } else {
        vol[i] <- Omega(auxi)
      }
    }
  }
  sum(vol^num)^(1 / num)
}

sampling_overlap <- function(A,B){
  mat <- solve(B) %*% A
  Nsample <- 10^5
  abunbance_all <- rmvnorm(n = Nsample, mean = rep(0, nrow(A))) %>% 
    {abs(./sqrt(rowSums(.^2)))}
  get_feasibility <- function(N_A){
    N_B <- mat %*% matrix(N_A,ncol=1) %>% c()
    if_else(sum(N_B >= -1e-10) == length(N_B), 1, 0) 
  }
  percent <- 1:Nsample %>% 
    map_dbl(~get_feasibility(abunbance_all[.x,])) %>% 
    mean()
  Omega(A) * percent^(1/nrow(A))
}


# function that computes the overlap of two feasibility domains
# inputs: A = one interaction matrix, B = another interaction matrix
# output: volume_overlap = the normalize feasibility of the intersection region
Omega_overlap <- function(A, B) {
  A <- as.matrix(A)
  B <- as.matrix(B)
  
  num <- nrow(A)

  overlap_vertex <- vertex_detection(A, B)
  if (qr(overlap_vertex)$rank < num) {
    volume_overlap <- 0
  } else {
    partition <- partitionize(overlap_vertex)
    volume_overlap <- total_volume(partition, overlap_vertex)
  }

  volume_overlap <- sampling_overlap(A,B)
  volume_overlap
}

# function that generates a random matrix (as in May, Nature (1972))
# inputs: alpha = interaction matrix; inequality = biological linear ineqaulity
# output: the size of the constrained feasibility domain
Omega_with_inequality_constraints <- function(alpha, inequality){
  beta <- alpha
  for(j in 1:ncol(alpha)){
    beta[,j] <- -alpha[,j] / (-alpha[,j] %*% inequality)
  }
  abs(det(beta))
}

# function that generates a random matrix (as in May, Nature (1972))
# inputs: num = number of species; stren = standard deviation of interaction strength; conne = connectance of the interaction matrix
# output: Inte = the generated random matrix
interaction_matrix_random <- function(num, stren, conne){
  Inte <- rnorm(num*num, mean = 0, sd = stren)
  zeroes <- sample(c(rep.int(1,floor(num*num*conne)),rep.int(0,(num*num-floor(num*num*conne)))))
  Inte[which(zeroes==0)] <- 0
  Inte <- matrix(Inte, ncol = num, nrow = num)
  diag(Inte) <- -1
  return(Inte)
}


#function that checks whether the chosen parameterization satisfies local stability
#inputs: A = interaction matrix; r = vector of intrinsic growth rates
#output: unstable = 0; stable= 1
check_local_stability <- function(A, r){
  N <- solve(A, -r)
  jacobian <- A %*% diag(N) 
  auxi <- sum(Re(eigen(jacobian)$values) < -1e-8)
  if(auxi==num) return(1)
  else return(0)
}


# function that check if two vectors  of the same length are on the same line
# inputs: a = vector 1, b = vector 2
# output: TRUE (on the same line) or FALSE(0)
vec_on_a_line <- function(a,b){
  c <- a/b
  if(length(unique(c))==1){
    res <- 1
  }else{
    res <- 0
  }
  res
}

# function that check if any two column vectors of a matrix are on the same line
# input: mat = matrix
# output: TRUE (existing two column vectors on the same line) or FALSE(0)
line_in_mat <- function(mat){
  n_vec <- ncol(mat)
  index_two <- combn(n_vec,2,simplify = FALSE)
  res <- 0
  for (two_vec in index_two) {
    a <- mat[,two_vec[1]]
    b <- mat[,two_vec[2]]
    res <- res + vec_on_a_line(a,b)
  }
  res
}

# function that computes the normalized feasibility of two species i,j in a S(>2) species community
# i.e., the necessary condition for i,j to coexist with others in the community
# (Note: not sufficient, r of others should locate in the convex cone to coexist)
# inputs: A = interaction matrix of S(>2)-species community,
#         pair = index vector of the two species
# output: res = the normalized feasibility of species i,j
Omega_proj <- function(A,pair){
  span_vec_set_ij <- -A[pair,] # projection of the spanning vectors of a n-dim (n>2) feasibility domain on the ij-coordinate plane
  ### check_irred: This routine checks the irreducibility of a set of edges, which are supposed to form the columns of a matrix. 
  ### If a column is a positive linear combination of other columns, then it can be removed without affecting the problem; 
  ### this routine delete the redundant columns and return a set of irreducible edges.
  span_vec_ij <- -t(check_irred(span_vec_set_ij)$edge) # spanning vectors of the projection on the ij-coordinate plane
  # If there is more than 2 spanning vectors, then Omega(i,j)=1
  if(ncol(span_vec_ij)>2){
    # Special case: if any two out of all 3 spanning vectors are on the same line, then Omega(i,j)=0.5
    if((ncol(span_vec_ij)==3)&&(line_in_mat(span_vec_ij))){
      res <- 0.5
    }else{
      res <- 1
    }
  }else if (ncol(span_vec_ij)==2){
    # If there is only two spanning vectors, then Omega(i,j) can be calculated using the spanning vectors
    res <- Omega(span_vec_ij) 
  }
  res
}

# function that computes the feasibility domains of a pair of species in a large S(>2)-species community
# inputs: A = S by S interaction matrix of the entire community, 
#         pair = index vector of the two species
# output: omega_comm = the normalized feasibility of the pair
Omega_comm <- function(A,pair){
  S <- nrow(A)
  A_pair <- A[pair,pair]
  A_temp_perm <- permutations(n=2,r=S-2,v=c(-1,1),repeats.allowed=TRUE) # all possible cases for interactions of theoretical species
  num_A_temp <- nrow(A_temp_perm)
  omega_comm <- 0
  for(n_A_temp in 1:num_A_temp){
    A_temp <- matrix(0, nrow = S, ncol = S)
    A_temp[pair,pair] <- A_pair
    if(S == 3){
      A_temp[-pair,-pair] <- A_temp_perm[n_A_temp,] # to avoid error of diag()
    }else{
      diag(A_temp[-pair,-pair]) <- A_temp_perm[n_A_temp,]
    }
    omega_comm <- omega_comm + (Omega(A_temp)-Omega_overlap(A,A_temp))
  }
  omega_comm <- omega_comm + Omega(A)
  omega_comm
}

# function that computes the feasibility domain of a pair of species in a large S(>2)-species community
# note that this is just an **approximation**
# inputs: A = S by S interaction matrix of the entire community, 
#         pair = index vector of the two species
# output: omega_comm = the normalized feasibility of the pair
Omega_comm_2 <- function(A,pair){
  S <- nrow(A)
  omega <- 0
  # first term: sum all omega
  for(S_sub in 2:(S-1)){
    S_other <- S_sub - 2
    other_comb <- combn(c(1:S)[-pair],S_other,simplify = FALSE)
    for (other in other_comb){
      sub <- sort(c(pair,other))
      A_sub <- A[sub,sub]
      A_omega_perm <- permutations(n=2,r=S-S_sub,v=c(-1,1),repeats.allowed=TRUE) # all possible cases for interactions of theoretical species
      num_A_omega <- nrow(A_omega_perm)
      for(n_A_omega in 1:num_A_omega){
        A_omega <- matrix(0, nrow = S, ncol = S)
        A_omega[sub,sub] <- A_sub
        if(S == S_sub+1){
          A_omega[-sub,-sub] <- A_omega_perm[n_A_omega,]
        }else{
          diag(A_omega[-sub,-sub]) <- A_omega_perm[n_A_omega,]
        }
        omega <- omega + Omega(A_omega)
      }
    }
  }
  omega <- omega + Omega(A)
  # minus overlaps
  overlap <- 0
  for(S_high in (2+1):S){
    for(S_low in 2:(S_high-1)){
      low_comb <- combn(c(1:S)[-pair],S_low-2,simplify = FALSE)
      for(low in low_comb){
        sub_low <- sort(c(pair,low))
        A_sub_low <- matrix(0, nrow = S, ncol = S)
        A_sub_low[sub_low,sub_low] <- A[sub_low,sub_low]
        if(all(diag(A)<0) == TRUE){
          diag(A_sub_low) <- -1
        }else{
          diag(A_sub_low) <- 1
        }
        high_comb <- combinations(S-S_low, S_high-S_low, v = c(1:S)[-sub_low])
        num_high <- nrow(high_comb)
        for(n_high in 1:num_high){
          high <- high_comb[n_high,]
          sub_high <- sort(c(sub_low,high))
          A_sub_high <- matrix(0, nrow = S, ncol = S)
          A_sub_high[sub_high,sub_high] <- A[sub_high,sub_high]
          if(S-S_high > 0){
            A_overlap_perm <- permutations(n=2,r=S-S_high,v=c(-1,1),repeats.allowed=TRUE) # all possible cases for interactions of theoretical species
            num_A_overlap <- nrow(A_overlap_perm)
            for(n_A_overlap in 1:num_A_overlap){
              if(S == S_high+1){
                A_sub_high[-sub_high,-sub_high] <- A_overlap_perm[n_A_overlap,]
                A_sub_low[-sub_high,-sub_high] <- A_overlap_perm[n_A_overlap,]
              }else{
                diag(A_sub_high[-sub_high,-sub_high]) <- A_overlap_perm[n_A_overlap,]
                diag(A_sub_low[-sub_high,-sub_high]) <- A_overlap_perm[n_A_overlap,]
              }
              overlap <- overlap + Omega_overlap(A_sub_high,A_sub_low)
            }
          }else{
            overlap <- overlap + Omega_overlap(A_sub_high,A_sub_low)
          }
        }
      }
    }
  }
  omega_comm <- omega-overlap
  omega_comm
}

# function that computes the **true** feasibility domain of a subset of species in a large S(>2)-species community analytically
# note that this is for just one region
# inputs: A = S by S interaction matrix of the entire community, diag(A) = -1 
#         species = index vector of the subset of species
# output: omega_comm_anal = the normalized feasibility of the pair while others are transient
Omega_comm_anal <- function(A,species){
  S <- nrow(A)
  B <- matrix(0,nrow = S,ncol = S)
  diag(B) <- 1
  
  other <- c(1:S)[-species]
  A_species <- cbind(A[,species],B[,other])
  omega_comm_anal <- Omega(A_species)
  omega_comm_anal
}

# function that computes the **true overall** feasibility domain of a subset of species in a large S(>2)-species community analytically
# note that this is for a combination of regions
# inputs: A = S by S interaction matrix of the entire community, diag(A) = -1 
#         species = index vector of the subset of species
# output: Omega_comm_analytical = the normalized feasibility of the pair across all possible comms
Omega_comm_analytical <- function(A,species){
  S <- nrow(A)
  S_sub <- length(species)
  S_other <- S-S_sub
  
  Omega_comm_analytical <- Omega_comm_anal(A,species)
  for(s in 1:S_other){
    other_comb <- combinations(S_other,s,c(1:S)[-species])
    n_other_comb <- nrow(other_comb)
    for(n in 1:n_other_comb){
      other <- other_comb[n,]
      comm <- sort(c(species,other))
      Omega_comm_analytical <- Omega_comm_analytical + Omega_comm_anal(A,comm)
    }
  }
  Omega_comm_analytical
}

###########################
###########################
